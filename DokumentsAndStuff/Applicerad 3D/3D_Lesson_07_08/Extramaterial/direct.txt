Nu har ni fått in ett ambientljus somser najs ut
Om ni vill så kan ni multiplisera ert ambienta ljus med en ambientIntensity för att ge grafikerna mer kontroll över looken på spelet.

Men nog om ambiens
Nu är det dax för Direkta ljus!

Ni har redan kod som låter er att ha en väldigt grundläggande direkt ljusmodell.
Denna ljusmodell består utav ljusetsfärg * ljusetsAllaAttenuations

Ni har även redan kod som tar denna ljusmodellen, multipliserar den med albedon och lamberten, för att få ut ett direkt diffust ljus.
Nu ska vi använda denna ljusmodellen på ett annat ställe också.
I en direkt spec!


Den formeln som vi vill använda ser ut såhär
	dirSpec = (F(l, h) * G(l, v, h) * D(h)) / (4(n.l)(n.v))

Det är den som är vår direkta spec formel. Men för att vi ska kunna köra den behöver vi några variabler
	l = ljusriktningen
	v = viewriktningen
	h = halvvectorn mellan l och v
	n = ytans normal



Vi börjar i början med Fresnel! Fresnellen är precis som reflectionsFresnellen i det ambienta, fast den är gjord mer för direkta ljus.
	float3 Fresnel(const float3 substance, const float3 lightDir, const float3 halfVec)
	{
		float LdotH = dot(lightDir, halfVec);
		LdotH = 1.0f - LdotH;
		LdotH = pow(LdotH, 5);
		float3 fresnel = LdotH * (1.f - substance);
		fresnel = substance + fresnel;
		return fresnel;
	}


Sen behöver vi beräkna geometrifunktionen. Men för att vara extra optimerade kan vi även slänga in den sista delen här. Detta paketet kallas för synlighetsfunktionen.
	float V_SchlickforGGX(float roughness, float NdotV, float NdotL)
	{
		float k = roughness * roughness * 0.5f;
		float G1V = NdotV * (1.f - k) + k;
		float G1L = NdotL * (1.f - k) + k;
		return 0.25f / (G1V * G1L);
	}


Sist måste vi beräkna normaldistrubutionen på materialet. Det är här Disneys GGX kommer in och gör saker fräsigt. Denna formeln kan ni även hitta i en powerpoint.
	float D_GGX(float HdotN, float roughness)
	{
		float m = roughness * roughness;
		float m2 = m * m;
		float denominator = HdotN * HdotN * (m2 - 1.f) + 1.f;
		float D = m2 / (3.14159 * denominator * denominator);
		return D;
	}



Sen ska vi bara kombinera ihop allt. totalAttenuation ska vara den totala attenuationen på ert ljus. Detta är kod för directionallight så attenuationen är en konstant 1 överallt. LightOfLight är ljusets ljus, dvs det ljuset som ljuset producerar.
	float totalAttenuation = 1;
	float3 lightOfLight = DirectionalLightolor[i].xyz * totalAttenuation;


Här skapar vi upp alla variabler som vår GGXPBL kommer att behöva.
	float3 lightDir = normalize(DirectionalLightDir[i].xyz);
	float3 halfVec = normalize(lightDir + toEye.xyz);
	float NdotL = saturate(dot(pixel.normal, lightDir));
	float HdotN = saturate(dot(halfVec, pixel.normal));
	float NdotV = saturate(dot(pixel.normal, toEye));


Sen kör vi PBLdelen! Vill ni ha mer information om de olika delarna så kan ni läsa det jag skickade ut för ett tag sedan. Notera även att jag skapar en lambertvariabel som bara är NdotL. Detta är för att saker ska vara lite tydligare i koden.
	float3 F = saturate(Fresnel(pixel.substance, lightDir, halfVec));
	float D = saturate(D_GGX(HdotN, (pixel.roughness + 1) / 2));
	float V = saturate(V_SchlickforGGX((pixel.roughness + 1) / 2, NdotV, NdotL));
	float lambert = NdotL;


Här kommer själva beräkningen av det direkta ljuset. Som ni ser så kommer F och (1 - F) in igen. Detta är för att hålla direkta ljus energy conserving.
	directDiffuse += saturate((1 - F) * lambert * pixel.metalnessAlbedo * lightOfLight);
	directSpec += F * D * V * NdotL * lightOfLight;


	
Sist så bara adderar vi allt.
	return float4(saturate(ambientDiffuse + ambientSpec + directDiffuse + directSpec + emissive).xyz, 1);



Vill ni verkligen se så att saker fungerar, så kan ni dra upp intensiteten på era ljus till typ 4-5. Då borde ni se en spec som specar loss! (monkey)